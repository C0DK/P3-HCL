HCLANG - EBNF

Notation:
Terminal: lowercase
Non-terminal: PascalCase
something:    1 occurrence of something
[something]:  something 0 or 1 times
{something}:  something 0 or more times
{something}+: something 1 or more times
@x-y: Any Unicode character from x to y

***********************************************************************************

AnyPrintableChar --> @a-z
                   | @A-Z
                   | @0-9
                   | **FINISH THIS**

Digits --> @0-9 [Digits]

Operator --> BracketL
           | BracketR
           | ParenL
           | ParenR
           | CurlyL
           | CurlyR
           | =
           | ::
           | <
           | >

CurlyL   --> {
CurlyR   --> }
ParenL   --> (
ParenR   --> )
BracketL --> [
BracketR --> ]

Type --> number
       | text
       | tuple
       | list
       | dict
       | char
       | none

Linebreak --> \r\n
            | ;

VarIdentifier   --> IdentifierStart AnyPrintableChar
IdentifierStart --> @a-z
                  | @A-Z
                  | **FINISH THIS**

Expression --> FunctionCall
             | Value

Value --> Literal
        | VarIdentifier

Literal --> LiteralNumber
          | LiteralText
          | LiteralChar
          | LiteralTuple
          | LiteralList
          | LiteralDict

LiteralNumber --> Digits [. Digits]
LiteralText   --> "{AnyPrintableChar}"
LiteralChar   --> 'AnyPrintableChar'
LiteralTuple  --> ParenL Literal, Literal {, Literal} ParenR            (1, 2, "hello")
LiteralList   --> BracketL Literal {, Literal} BracketR                 [1, 2, 3, 4]
LiteralDict   --> 

Statements --> {Statement}+
Statement  --> VarDcl
             | VarAssign
             | FunctionCall
             | FunctionDcl

VarDcl    --> Type VarIdentifier [= Expression] Linebreak
VarAssign --> VarIdentifier = Expression Linebreak

FunctionIdentifier --> IdentifierStart {AnyPrintableChar}
FunctionDcl     --> func FunctionIdentifier = ParenL [FunDclParamList] ParenR -> Type CurlyL Statements CurlyR
FunDclParamList --> Parameter [, FunDclParamList]
Parameter       --> Type (VarIdentifier | FunctionIdentifier)

FunctionCall --> FunctionIdentifier
               | FunCallParameter FunctionIdentifier
               | FunCallParameter FunctionIdentifier FunCallParamList
FunCallParamList --> {FunCallParameter}+
                   | ParenL {FunCallParameter}+ ParenR
FunCallParameter --> Value
                   | ::FunctionIdentifier
                   | LambdaExpression

LambdaExpression --> CurlyL Statements CurlyR