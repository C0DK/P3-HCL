
Conventions
t1,t2,....,tn is written as t~
t1 ... tn is written as t* (t+ if non-empty)







Metavariables & Syntax for values

a in A_expr
b in B_expr
t in Txt_expr
tf in {tt, ff}
n in Num
str in " SIGMA-STAR "  (any string made from our alphabet)
x in Var
S in Stmt
p in P_navne
RESERVED in SIGMA-STAR       (our reserved words as well as identifiers already in use)
FreeId in SIGMA-STAR \ RESERVED  (identifiers not already in use)




:p ::= function pointer (where p in P_navne)
L ::= lambda
e ::= expression
f ::= function
T ::= type


a ::= n | x | a1 + a2 | a1 - a2 | a1 * a2 | a1 / a2
b ::= tf | x | a1 < a2 | a1 > a2 | a1 <= a2 | a1 >= a2 | a1 = a2 | b1 AND b2 | b1 OR b2 | NOT b
t ::= str | x | t1 + t2
list ::= [e~] | x
tuple ::= (e~) | x
S ::= x := eOrF | S1;S2 | b then L | b thenElse L1 L2 | b whileTrue L | list forEach L | fcall | Dv | Dp | return e | epsilon
Dv ::= T x := e; Dv | T x; Dv | epsilon
Dp ::= T f := ([T x]~): T { S }; Dp | T f; Dp | epsilon

pv ::= a | b | t                %primitive value
npv ::= list | tuple | pv | x   %non-primitive value
e ::= npv | fcall | (e)
eOrL ::= e | L
fcall ::= p | eOrL p eOrL*
L ::= { S } | :p




L = set of configurations (upside-down L)
T = set of final configurations
R = all real numbers
-> = transition function

(L_A_expr, -a>, T_A_expr)
    L_A_expr = A_expr U R
    T_A_expr = R

(L_B_expr, -b>, T_B_expr)
    L_B_expr = B_expr U {tt, ff}
    T_B_expr = {tt, ff}

(L_Txt_expr, -txt>, T_Txt_expr)
    L_Txt_expr = Txt_expr U {SIGMA-STAR}
    T_Txt_expr = {SIGMA-STAR}