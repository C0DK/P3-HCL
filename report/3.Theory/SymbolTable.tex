%THIS SECTION IS SUPPOSED TO BE A SUBSECTION TO THE PARSER SECTION.
%Should present the interface, which all symbol table implementations must implement.
%Should clarify all considerations through the design process.
\subsection{Symbol Table}
This section concerns with the implementation of the symbol table. 
First, the interface implemented by the the symbol table will be presented.
Second, all considerations through the design process will be discussed.
This will serve as the reasoning behind the final implementation details.

\textbf{Symbol Table Interface}\\
The interface consists of five functions as seen in snippet \ref{lis:STInterface}.

\begin{lstlisting}[language=java,label=lis:STInterface,caption=The interface which all symbol table implementations must implement.]
interface ISymbolTable{
fun openScope()
fun closeScope()
fun enterSymbol(name: String, type: TreeNode.Type): Boolean
fun retrieveSymbol(name: String): Symbol
fun declaredLocally(name: String): Boolean
}
\end{lstlisting}

The functions on line 2 and 3 concerns with the handling of scopes.
Scopes are handled by a stack data structure.
Intuitively, each element on the stack consists of a local symbol table concerning the current scope.

The $openScope()$ function opens a new scope in the symbol table.
This is done by pushing a new sub-symbol table onto the stack.

The $closeScope()$ function closes the most recently opened sub-symbol table.
This is done by popping the table from the stack.
Symbol references subsequently revert to outer scopes.

The functions on line 4 and 5 concerns with the handling of entering and retrieval of symbol information.
Since retrieval is the most heavily utilized function in the symbol table implementation, it is essential that time spent on the procedure is minimal.
Because of this all symbol tables uses a hash table data structure for insertion and retrieval of symbols. 

The $enterSymbol(name: String, type: TreeNode.Type): Boolean$ function enters a new symbol into the current scope on top of the stack.
The \texttt{name} parameter of type \texttt{String} must be matched with the identifier name in question.
The \texttt{type} parameter of type \texttt{Treenode.Type} must be matched with a valid AST-node type.
The function returns a boolean value indicating whether the operation was successful.

The $retrieveSymbol(name: String): Symbol$ function retrieves the symbol stored in the top sub-symbol table on the stack with the name indicated by the \texttt{name} parameter of type \texttt{String}.

The function on line 6 is concerned with the testing whether a symbol is declared in the local scope.

The $declaredLocally(name: String): Boolean$ function tests whether name is present in the symbol table's current scope.

\textbf{Considerations}\\
As described previously, scoping is handled with a stack data structure and the sub-symbol tables themselves are handled with a hash table data structure.
This is not the only way to implement symbol tables.
Instead of a stack data structure, the scope management could have been implemented using an attribute based data structure.
Specifically the depth of the scope could be implemented as attribute of the symbol itself.
By using indexing on the scope management data structure, the entire symbol table could have been implemented as one large table.
However, by simply comparing the amount of code necessary to implement the single-table and the stack table implementations, it was apparent that the stack table implementation would be simpler to implement.

The choice of using a hash table data structure for the sub-tables themselves was based upon the time complexity of the essential procedures.
As mentioned earlier, the \texttt{retrieveSymbol} function would be called more frequently than the remaining functions.
It was therefore deemed sufficient to implement the data structure with the most efficient search operations.
Insertion or retrieval in a hash table data structure can be performed in constant time.
