%This section covers the implementation of the lexer
\section{Lexer implementation}
As described in section \ref{LexerChoice}, it was decided that the lexer (and therefore the parser), would be written by hand.
As mentioned in section \ref{REFTOPROGRAMLANGUAGECHOICE}, the compiler for HCL will be written in kotlin.
Below is an explanation of the implementation of the lexer.

The lexer is comprised of 3 different classes the token class, the positional token class and the lexer class.

The token class, simply contains the type of the token. 
It is implemented as a Sealed class. 
A sealed class in Kotlin, simply specifies that a value can have one specific type, from a predefined set\cite{KotlinSealed}.
It is essentially an extended enum.
\begin{lstlisting}[language=java,label=lis:tokenClass,caption=A snippet from the token class .,firstnumber=9]
sealed class Literal : Token() {
class Text(val value: String) : Literal()
class Number(strValue: String, val value: Double = strValue.toDouble()) : Literal()
class Bool(val value: Boolean) : Literal()
}
\end{lstlisting}

The positional token class is a wrapper class from a token, and simply contains additional information regarding linenumer and line index.
The positional token is mainly implemented to help with error reporting. %Is this correct
\begin{lstlisting}[language=java,label=lis:PositionalTokenClass,caption=A snippet from the token class .,firstnumber=10]
class PositionalToken(val token: Token, val lineNumber: Int, val lineIndex: Int)
\end{lstlisting}

The bulk of the logic regarding the lexer is done in the lexer class.
The lexer class implements the ILexer interface and accepts an input string, which is expected to be text.

\begin{lstlisting}[language=java,label=lis:Lexer,caption=The Lexer .,firstnumber=8]
class Lexer(private val inputContent: String) : ILexer {
\end{lstlisting}

The ILexer defines a getTokenSequence function, which will give the token sequence and an inputLine function.
The getTokenSequence function will split the text string.
\begin{lstlisting}[language=java,label=lis:LexerStringSplit,caption=The string is being split and new lines are added to the string .,firstnumber=8]
class Lexer(private val inputContent: String) : ILexer { 
        val currentString = StringBuilder()
inputContent.split(endOfLineRegex).forEachIndexed { lineNumber, line ->
	(line + "\n").forEachIndexed { indexNumber, char ->
		if (char !in listOf(' ', '\t')) currentString.append(char)
		with(currentString.toString()) {
\end{lstlisting}		
It will then match the characters to either a type, a boolean value, a special character, an identifier or a number literal.
If this is not possible, it can be assumed that the split string, meaning the current line, is done.
\begin{lstlisting}[language=java,label=lis:LexerStringMatcher,caption=The split string is being matched to a token,firstnumber=19]
when {
	// types
	equals("var") -> Token.Type.Var()
	equals("none") -> Token.Type.None()
	equals("txt") -> Token.Type.Text()
	equals("num") -> Token.Type.Number()
	equals("bool") -> Token.Type.Bool()
	equals("tuple") -> Token.Type.Tuple()
	equals("list") -> Token.Type.List()
	equals("func") -> Token.Type.Func()
	//bool
	equals("true") -> Token.Literal.Bool(true)
	equals("false") -> Token.Literal.Bool(false)
	// special char
	isSpecialChar() -> getSpecialCharTokenOrNull()
	// identifier or number literal
	upcomingSpecialCharOrWhiteSpace(lineNumber, indexNumber + 1) && isNotEmpty() -> getLiteralOrIdentifier()
	else -> null
}.let {
	if (it != null) {
		yield(PositionalToken(it, lineNumber, indexNumber - (length - 1)))
		currentString.setLength(0)
	}
}
\end{lstlisting}