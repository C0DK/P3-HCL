% !TeX root = ../main.tex
%Content includes all type rules in HCL
%Should be a relatively short section, since much of the content is self explanatory.
\section{Type Rules}
HCL employs types.
This is done because of three reasons:
\begin{itemize}
	\item To avoid certain runtime errors, which would not have been caught beforehand (these errors are explained below).
	\item It makes it a lot easier to allocate memory\footnote{This is not immediately crucial to HCL since i it compiles to C++, which have a type system.
	}.
	\item As described in the problem analysis, types makes it easier for novices to understand constructions such as function definitions.
\end{itemize}
The code snippet shown in listing \ref{lis:TypeEx} is a syntactically correct assignment in HCL.
If HCL did not have types, the assignment would lead to a runtime error since the second argument to the plus function would evaluate to a value of type bool, since the plus function requires that the two arguments are of the same type, this is an error.

To avoid this, the HCL compiler utilize a type checker.
This will be described in later chapters.
\begin{lstlisting}[language=HCL,label=lis:TypeEx,caption=An HCL expression,firstnumber=9]
x = 10 + (2 equals 3)
\end{lstlisting}

The HCL type system consists of three components:
\begin{itemize}
	\item The set of all types in HCL.
	\item A type rules for each syntactic category.
	\item A definition for each type rule.
\end{itemize}

Essentially, the type rules specify when certain expressions have to evaluate to specific types.
The rules have been split up in two sections:
\begin{itemize}
	\item Rules for expressions
	\item Rules for statements
\end{itemize}
The former specifies which type an expression evaluates to, depending on the input.
The latter specifies what types the components of a statement must be to be type valid.

\textbf{Notation}\\
The notation for type rules is very similar to the notation of semantics with few differences.
Below is an example:\\
\begin{center}
	\begin{math}
	\cfrac
	{E \vdash e_1 : num \quad e_2 : num}
	{E \vdash e_1\ + e_2 : num}
	\end{math}
\end{center}
This is the type rule for addition of two numbers.
It means that given the current environment, the resulting value will be of type $num$ if the two input expressions are both of type $num$.

As the type rules do not change the state of a program, and therefore also do not change the variable- and function environments, the environment can be simplified to one symbol, $E$.
The colon is used to show that an expression is of a certain type.

\subsection{Type Rules for Expressions}
%Introduktion


\textbf{Variable type}\\
The type of a variable is found by looking up the variable in the environment:\\
\begin{center}
	\begin{math}
	E(x) : T
	\end{math}
	\\[1\baselineskip]
	\texttt{where} $T$ is the type that the variable was declared with
\end{center}


\textbf{Num type}\\
\begin{center}
	\begin{math}
		E \vdash n : num
	\end{math}
\end{center}

\textbf{Bool type}\\
\begin{center}
	\begin{math}
	E \vdash b : bool
	\end{math}
\end{center}

\textbf{Txt type}\\
\begin{center}
	\begin{math}
	E \vdash t : txt
	\end{math}
\end{center}

\textbf{List type}\\
\begin{center}
	\begin{math}
	E \vdash lst : list[T]
	\end{math}
	\\[1\baselineskip]
	\texttt{where} $T \notin \{none, var, generic\}$
\end{center}

\textbf{Tuple type}\\
\begin{center}
	\begin{math}
	E \vdash tpl : tuple[T_1, \ .
	.
	.
	\ ,\ T_k]
	\end{math}
	\\[1\baselineskip]
	\texttt{where} $T_i \notin \{none, var, generic\}$\\
	\texttt{and} $k > 0$\\
	\texttt{and} $1 \le i \le k$
\end{center}

\textbf{Function type}\\
\begin{center}
	\begin{math}
	E \vdash f : func[T_1,\ .
	.
	.
	\ ,\ T_k]
	\end{math}
	\\[1\baselineskip]
	\texttt{where for each} $T \in \{T_1,\ .
	.
	.
	\ ,\ T_{k-1}\},\ T \notin \{none, var\}$\\
	\texttt{and} $T_k \notin \{var\}$\\
	\texttt{and} $k > 0$
\end{center}

\textbf{Lambda type}\\
\begin{center}
	\begin{math}
	E \vdash \{\ S\ \} : func[T_1,\ .
	.
	.
	\ ,\ T_k]
	\end{math}
	\\[1\baselineskip]
	\texttt{where} $T_k$ is the type of the return expression\\
	\texttt{and} $T_1, \ .
	.
	.
	\ ,\ T_{k-1}$ are inferred from the function whom the expression is the argument for%Jeg er ikke sikker på, om denne sætning beskriver det godt nok
\end{center}

For the sake of brevity, the type rules for expressions have been simplified significantly compared to the semantic rules.
Unlike the semantics, where certain function calls must have its own rule in order for the semantics of HCL to be properly defined, the type rules for all function calls can be explained with a single rule.
\textbf{Function call}\\
\begin{center}
	\begin{math}
		\cfrac
		{E \vdash e_1 : T_1 \ .
		.
		.
		\ E \vdash e_k : T_k}
		{E \vdash e_1\ f\ e_2 \ .
		.
		.
		\ e_k : T_f}
	\end{math}
	\\[1\baselineskip]
	\texttt{where} $f$ is a function identifier\\
	$e_1\ .
	.
	.
	\ e_k$ are the expressions passed to function $f$\\
	\texttt{and} $T_1\ .
	.
	.
	\ T_k$ are the types of the formal parameters of $f$\\
	\texttt{and} $T_f$ is the return type of $f$\\
	\texttt{and} $k \ge 0$
\end{center}



\subsection{Type Rules for Statements}
%quick introduction.
The type rules for statements are, as mentioned earlier, different from the rules for expressions.
%explain what "ok" means
\textbf{Compositional type rule}\\
\begin{center}
	\begin{math}
	\cfrac
	{E \vdash S_1 : \texttt{ok}\quad E \vdash S_2 : \texttt{ok}}
	{E \vdash S_1;S_2 : \texttt{ok}}
	\end{math}
	\\[1\baselineskip]
	\texttt{where} $T \in \{num, bool, txt, list, tuple\}$
\end{center}


\textbf{Explicit variable declaration}\\
\begin{center}
	\begin{math}
		\cfrac
		{E \vdash e : T}
		{E \vdash T\ x = e : \texttt{ok}}
	\end{math}
	\\[1\baselineskip]
	\texttt{where} $T \in \{num, bool, txt, list, tuple\}$
\end{center}

\textbf{Implicit variable declaration}\\
\begin{center}
	\begin{math}
	E \vdash var\ x = e : \texttt{ok}
	\end{math}
\end{center}

\textbf{Explicit function declaration}\\
\begin{center}
	\begin{math}
		\cfrac
		{E\vdash S : \texttt{ok}\quad E \vdash U_1 : T_1\
			.
			.
			.
			\ E \vdash U_k : T_k}
		{E \vdash func[T_1,\
			.
			.
			.
			\ ,\ T_k]\ f = (U_1\ p_1\
			.
			.
			.
			\ U_{k-1}\ p_{k-1}): U_k\ \{\ S\ \} : \texttt{ok}}
	\end{math}
	\\[1\baselineskip]
	\texttt{where for each} $T \in \{T_1,\ .
	.
	.
	\ ,\ T_{k-1}\}\ T \notin \{none, var\}$\\
	\texttt{and} $T_k \notin \{var\}$
\end{center}

\textbf{Implicit function declaration}\\
\begin{center}
	\begin{math}
		\cfrac
		{E\vdash S : \texttt{ok}\quad}
		{E \vdash func\ f = (T_1\ p_1,\
		.
		.
		.
		\ ,\ T_{k-1}\ p_{k-1}): T_k\ \{\ S\ \} : \texttt{ok}}
	\end{math}
	\\[1\baselineskip]
	\texttt{where for each} $T \in \{T_1,\ .
	.
	.
	\ ,\ T_{k-1}\}\ T \notin \{none, var\}$\\
	\texttt{and} $T_k \notin \{var\}$
\end{center}


The type system is used to create the type checker component of the HCL compiler. Which will be described in later chapters.
Essentially, a snippet of code is valid, if it is possible to create a transition tree of rules using the type system. 
%Conclusion.

