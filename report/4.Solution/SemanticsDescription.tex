% How to do quick maths tutorial (HD).
% The lines in the derivations are just fraction lines (made with \cfrac{}{}).
% Sideways T (turnstile - bom in Danish) is \vdash.
% The weird, tall "<" ">" brackets are \langle and \rangle.

\section{Semantics of HCL}
%Introduction -- Contains all asumptions -> Environment, Store Model.
%										    Fully static scope rules.
%											Rundown of content.

The notation used to formalize the semantics of HCL in the following section will be operational structural semantics.

%...
As mentioned before in the previous chapters, HCL contains an atypical few number of operators.
To ease the reader's understanding of HCL's semantics, all functions part of HCL's standard library will be adopted to the notation of the semantics. 
%...

%...
All transitions are written using Big-Step semantics, BSS for short.
%...

%...
The Environment-store-model will be used to describe how the state of variables and procedures are bound.
%...

%...
In the following section, semicolons used in semantic rules are to be left associative.
For example; $S_1;S_2;S_3$ must be read as $S_1;(S_2;S_3)$.
The components of this statement are $S_1$ and $S_2;S_3$.
%...

%...
HCL allows for the use of ';' and '{\}n' for line endings.
for simplicity, will the abstract syntax and rules in this section utilize ';' for line endings. 
%...

\subsection{Abstract Syntax}
The abstract syntax will now be presented.
For convenience, the following notational conventions will be followed throughout this section.

In the rest of the section $t1, .
.
.
 , tn$ will be abbreviated with $t\textasciitilde$ and $t1 .
 .
 .
  tn$ with $t^*$ ($t^+$ in the non-empty case).

The syntax categories and meta-variables used in the semantic can be seen in table \ref{tab:metaVarab}. 
\begin{center}
	\begin{table}[ht]
		\centering
		\caption{The syntax categories and meta-variables used in the operational semantics of HCL}
		\label{tab:metaVar}
		\begin{tabular}{ll}
			\textbf{Metavariable} & \textbf{Name} \\
			$a \in A_{exp}$ 	  & Arithmetic expression \\
			$n \in Num$			  & Number Literal \\
			$x \in Var$           & Variable \\
			$b \in B_{exp}$		  & Boolean expression\\ 
			$tf \in {True,False}$ & Boolean literal \\
			$t \in Txt_{exp}$     & Text expression\\
			$str \in {\Sigma^*}$  & String Literal \\
			$list \in list_{exp}$ & List expression \\
			$lst \in List$		  & List literal\\
			$tupple \in tpl_{exp}$& Tupple expression\\
			$tpl \in Tupple$	  & Tupple Literal\\
			$L \in Lambda$		  & Lambda expression\\
			$e \in Exp$			  & Expression\\
			$el \in Lit$		  & Expression Literal\\
			$p \in Pnames$        & Procedure names\\
			$L \in Lambda$        & Statement Lambdas\\
			$S \in Stm$           & Statement\\
			$f \in Fnames$ 		  & Function names\\
			$D_V \in Dcl_V$		  & Variable declaration \\
			
			$T \in Type$          & Types
		\end{tabular}
	\end{table}
\end{center}

For the rest of this section, it will be assumed that functions exists with domains equal to the sets of literals associated with the various expressions' syntax categories, and with co-domains equal to the values extracted from those literals.
The abstract syntax of HCL can be seen below.

$a ::= n | x | a_1+a_2 | a_1-a_2 | a_1*a_2 | a_1/a_2 | (a)$\\
$b ::= tf| x | a_1<a_2 | a_1>a_2 | a_1<=a_2| a_1>=a_2| a_1==a_2 | b_1\ and\ b_2 | b_1\ or\ b_2 | b\ not | (b)$\\
$t ::= str| x | t_1 + t_2 | t\ toString | (t)$\\
$list ::= lst | x | list\ @\ a | (list)$\\
$tupple ::= tpl | x | tupple\ @ | (tupple)$\\
$e ::= a | b | t | list | tupple | call_{exp}$\\
$f ::= f | eOrL\ f\ eOrL^*$\\
$eOrL ::= e | L$\\
$pOrf ::= f | p$\\
$D_v ::= T\ x\ =\ e;\ S | T\ x\ = call_{exp};\ S | T\ x;\ D_v | \epsilon$\\
$D_p ::= T\ pOrf\ =\ ([T\ x]\sim):\ T\ L;\ S |T\ pOrf;\ S | \epsilon$

\textbf{\large{Conventions}} \\
For each variable $x$, an arbitrary variable-environment $env_V$ describes which address $adr$, $x$ is bound to.
For simplicity, the set of all possible addresses, denoted $Adr$, is assumed to be equal to the set of all integers.
\begin{center}
	$Adr = \mathbb{Z}$
\end{center}
The set of all variable-environments, denoted \textbf{$Env_V$}, is the set of all partial functions from variables to addresses.
\begin{center}
	$Env_V = Var \cup \{next\} \rightharpoonup Adr$
\end{center}
For every $adr$, the function $new : Adr \rightarrow Adr$ returns the next $adr$, whether it is free or not.
\begin{center}
	$new (adr) = adr + 1$
\end{center}
A store $sto$ describes what values $v$ are pointed to by the addresses found in $Adr$.

With the variable bindings found in $env_V$ and the address content found in $sto$, the expressions are capable of returning the values of the $sto$.
This means that every transition of expressions must be on the form.
\begin{center}
	$env_V,sto \vdash e \rightarrow v$
\end{center} 

\subsection{Big-Step Semantic for Expressions}
%Quick introduction.

\textbf{\large{General Rules for Expressions}} \\
All expression in the abstract syntax have two rewriting rules in common.
The variable rule and the parenthesis rule.
To avoid the possibility of cluttering the section, these rules are described below, using the metavariable $e \in Exp$, where the syntax category $Exp$ is the set of all expressions.

\textbf{[$Parent_{BSS}$]}
\begin{center}
	\begin{math}
	\cfrac
		{env_V,\ sto \vdash e \rightarrow_e v}
		{env_V,\ sto \vdash (e) \rightarrow_e v}
	\end{math}
\end{center}

\textbf{[$Var_{BSS}$]}
\begin{center}
	\begin{math}
	env_V,\ sto \vdash x \rightarrow_e v
	\texttt{ if } env_V\ x = l
	\texttt{ and } sto\ l = v
	\end{math}
\end{center}

\textbf{\large{Arithmetic Expressions}}\\
Arithmetic expressions returns a value $v$, where $v \in \mathbb{Z}$ or $v \in \mathbb{R}$.
The transitions-system for $A_{exp}$ is $(A_{exp} \cup D, \rightarrow_a, D)$, 
where $D = \mathbb{Z} \cup \mathbb{R}$.
The transitions can be seen below.

\textbf{[$Add_{BSS}$]}\\
\begin{center}
	\begin{math}
	\cfrac
		{env_V,\ sto \vdash a_1 \rightarrow_a v_1 \quad env_V, sto \vdash a_2 \rightarrow_a v_2}
		{env_V,\ sto \vdash a_1 + a_2 \rightarrow_a v}
	\end{math}
	
	
	\texttt{where} $v = v_1 + v_2$
\end{center}

\textbf{[$Minus_{BSS}$]}\\
\begin{center}
	\begin{math}
	\cfrac
		{env_V,\ sto \vdash a_1 \rightarrow_a v_1 \quad env_V, sto \vdash a_2 \rightarrow_a v_2}
		{env_V,\ sto \vdash a_1 - a_2 \rightarrow_a v}
	\end{math}
	
	
	\texttt{where} $v = v_1 - v_2$
\end{center}

\textbf{[$Mult_{BSS}$]}\\
\begin{center}
	\begin{math}
	\cfrac
	{env_V,\ sto \vdash a_1 \rightarrow_a v_1 \quad env_V, sto \vdash a_2 \rightarrow_a v_2}
	{env_V,\ sto \vdash a_1 * a_2 \rightarrow_a v}
	\end{math}
	
	
	\texttt{where} $v = v_1 \cdot v_2$
\end{center}

\textbf{[$Div_{BSS}$]}\\
\begin{center}
	\begin{math}
	\cfrac
	{env_V,\ sto \vdash a_1 \rightarrow_a v_1 \quad env_V, sto \vdash a_2 \rightarrow_a v_2}
	{env_V,\ sto \vdash a_1 / a_2 \rightarrow_a v}
	\end{math}
	
	
	\texttt{where} $v = v_1 / v_2$
\end{center}

\textbf{[$Num_{BSS}$]}\\
\begin{center}
	\begin{math}
		env_V,\ sto \vdash n \rightarrow_a v
	\end{math}
	\texttt{ if } $\mathbb{N}[n] = v$
\end{center}

\textbf{\large{Boolean Expressions}}\\
Boolean expressions returns a value $v$, where $v \in \{True, False\}$.
The transition-system for $B_{exp}$ is $(B_{exp} \cup \{True, False,\} \rightarrow_b, \{True, False\})$.
The transition can be seen below.

\textbf{[$EqualTrue_{BSS}$]}\\
\begin{center}
	\begin{math}
		\cfrac
			{env_V,\ sto \vdash a_1 \rightarrow_a v_1 \quad env_V,\ sto \vdash a_2 \rightarrow_a v_2}
			{env_V,\ sto \vdash a_1 == a_2 \rightarrow_b True}
	\end{math}
	
	\texttt{ if } $v_1 = v_2$
\end{center}

\textbf{[$EqualFalse_{BSS}$]}\\
\begin{center}
	\begin{math}
	\cfrac
	{env_V,\ sto \vdash a_1 \rightarrow_a v_1 \quad env_V,\ sto \vdash a_2 \rightarrow_a v_2}
	{env_V,\ sto \vdash a_1 == a_2 \rightarrow_b False}
	\end{math}
	
	\texttt{ if } $v_1 \neq v_2$
\end{center}

\textbf{[$LessThanTrue_{BSS}$]}\\
\begin{center}
	\begin{math}
	\cfrac
	{env_V,\ sto \vdash a_1 \rightarrow_a v_1 \quad env_V,\ sto \vdash a_2 \rightarrow_a v_2}
	{env_V,\ sto \vdash a_1 < a_2 \rightarrow_b True}
	\end{math}
	
	\texttt{ if } $v_1 < v_2$
\end{center}

\textbf{[$LessThanFalse_{BSS}$]}\\
\begin{center}
	\begin{math}
	\cfrac
	{env_V,\ sto \vdash a_1 \rightarrow_a v_1 \quad env_V,\ sto \vdash a_2 \rightarrow_a v_2}
	{env_V,\ sto \vdash a_1 < a_2 \rightarrow_b False}
	\end{math}
	
	\texttt{ if } $v_1 \not< v_2$
\end{center}

\textbf{[$GreaterThanTrue_{BSS}$]}\\
\begin{center}
	\begin{math}
	\cfrac
	{env_V,\ sto \vdash a_1 \rightarrow_a v_1 \quad env_V,\ sto \vdash a_2 \rightarrow_a v_2}
	{env_V,\ sto \vdash a_1 > a_2 \rightarrow_b True}
	\end{math}
	
	\texttt{ if } $v_1 > v_2$
\end{center}

\textbf{[$GreaterThanFalse_{BSS}$]}\\
\begin{center}
	\begin{math}
	\cfrac
	{env_V,\ sto \vdash a_1 \rightarrow_a v_1 \quad env_V,\ sto \vdash a_2 \rightarrow_a v_2}
	{env_V,\ sto \vdash a_1 > a_2 \rightarrow_b False}
	\end{math}
	
	\texttt{ if } $v_1 \not> v_2$
\end{center}

\textbf{[$LessThanOrEqualTrue_{BSS}$]}\\
\begin{center}
	\begin{math}
	\cfrac
	{env_V,\ sto \vdash a_1 \rightarrow_a v_1 \quad env_V,\ sto \vdash a_2 \rightarrow_a v_2}
	{env_V,\ sto \vdash a_1 <= a_2 \rightarrow_b True}
	\end{math}
	
	\texttt{ if } $v_1 <= v_2$
\end{center}

\textbf{[$LessThanOrEqualFalse_{BSS}$]}\\
\begin{center}
	\begin{math}
	\cfrac
	{env_V,\ sto \vdash a_1 \rightarrow_a v_1 \quad env_V,\ sto \vdash a_2 \rightarrow_a v_2}
	{env_V,\ sto \vdash a_1 <= a_2 \rightarrow_b False}
	\end{math}
	
	\texttt{ if } $v_1 \not<\not= v_2$
\end{center}

\textbf{[$AndTrue_{BSS}$]}\\
\begin{center}
	\begin{math}
	\cfrac
		{env_V,\ sto \vdash b_1 \rightarrow_b True \quad env_V, sto \vdash b_2 \rightarrow_b True}
		{env_V,\ sto \vdash b_1\ and\ b_2 \rightarrow_b True}
	\end{math}
\end{center}

\textbf{[$AndFalse_{BSS}$]}\\
\begin{center}
	\begin{math}
	\cfrac
		{env_V,\ sto \vdash b_1 \rightarrow_b False \quad env_V,\ sto \vdash b_2 \rightarrow_b False}
		{env_V,\ sto \vdash b_1\ and\ b_2 \rightarrow_b False}
	\end{math}
\end{center}

\textbf{[$Not_{BSS}$]}\\
\begin{center}
	\begin{math}
	\cfrac
	{env_V,\ sto \vdash b \rightarrow_b v_2}
	{env_V,\ sto \vdash b\ not \rightarrow_b v_1}
	\end{math}
	
	\texttt{ where } $v_1 \in Bool - v_2$
\end{center}

\textbf{[$TFLit_{BSS}$]}\\
\begin{center}
	\begin{math}
	env_V,\ sto \vdash tf \rightarrow_b v
	\end{math}
	\texttt{ if } $\mathbb{B}[tf] = v$
\end{center}

\textbf{\large{Text Expressions}}\\
Text Expressions returns a value $v$, where $v$ is a sequence of characters from an arbitrary alphabet enclosed in $"$, abbreviated $str$.
In other words, $v$ is a string.
The transition-system for $Txt_{exp}$ is $(Txt_{exp} \cup \{\Sigma^*\},\ \rightarrow_t, \{\Sigma^*\})$.
Here $\Sigma$ is an arbitrary alphabet legal in the context.

\textbf{[$TextConc_{BSS}$]}\\
\begin{center}
	\begin{math}
	\cfrac
		{env_V,\ sto \vdash t_1 \rightarrow_b v_1 \quad env_V,\ sto \vdash t_2 \rightarrow_b v_2}
		{env_V,\ sto \vdash t_1 + t_2 \rightarrow_b v}
	\end{math}
	
	\texttt{ where } $v = v_1\ \circ\ v_2$
\end{center}

\texttt{[$TextToString_{BSS}$]}\\
\begin{center}
	\begin{math}
		\cfrac
			{env_V, sto \vdash e \rightarrow_{e} v'}
			{env_V, sto \vdash e\ toString \rightarrow_{t} v}
	\end{math}
	
	\texttt{ where } $v = "v'"$
\end{center}

\textbf{[$TextLit_{BSS}$]}\\
\begin{center}
	\begin{math}
	env_V,\ sto \vdash t \rightarrow_b v
	\end{math}
	\texttt{ if } $\mathbb{T}[t] = "v"$
\end{center}

\textbf{\Large{List Expressions}}\\
List expressions returns a value $v$, where $v$ consists of a sequence of expression values separated with commas, encapsulated in $[]$.
$v$ is denoted $lst$, and is on the form $[(el \cup Lambda)~]$.
The set of which it is an element of is denoted $Lit$.
The transition-system for $list_{exp}$ is $(list_{exp} \cup List, \rightarrow_{list}, List \cup e)$.
The transitions are shown below.
The length transition returns a value $v$, where $v \in Z$.
Even though this is an exception to the general description of a list expression, the transition has the same format as the rest of the transitions.

\texttt{[$ListLength_{BSS}$]}\\
\begin{center}
	\begin{math}
		\cfrac
			{env_V, sto \vdash num \rightarrow_{a} v}
			{env_V, sto \vdash list\ length \rightarrow_{list} v}
	\end{math}
	
	\texttt{ where } $num = |list|$
\end{center}

\texttt{[$ListAt_{BSS}$]}\\
\begin{center}
	\begin{math}
		\cfrac
			{env_V, sto \vdash a \rightarrow_{a} v' \quad env_V, sto \vdash ls_v' \rightarrow_e v}
			{env_V, sto \vdash list\ @\ a \rightarrow_{list} v}
	\end{math}
	
	\texttt{ where } $ls_v'\ is\ the\ v'th\ element\ of\ list$
\end{center}

\textbf{[$ListLit_{BSS}$]}\\
\begin{center}
	\begin{math}
	env_V,\ sto \vdash lst \rightarrow_{list} v
	\end{math}
	\texttt{ if } $\mathbb{LST}[lst] = v$
\end{center}

\textbf{\Large{Tupple Expressions}}\\
Tupple expressions returns a value $v$, where $v$ consists of a sequence of expression values separated with commas, encapsulated in $()$.
$v$ is denoted $tpl$, and is on the form $((el \cup Lambda)~)$.
The set of which it is an element of is denoted $Tupple$.
The transition-system for $tupple_{exp}$ is $(tupple_{tupple_exp} \cup Tupple, \rightarrow_{tupple}, Tupple)$.
The transitions are shown below.

\texttt{[$TplAt_{BSS}$]}\\
\begin{center}
	\begin{math}
	\cfrac
	{env_V, sto \vdash a \rightarrow_{a} v' \quad env_V, sto \vdash tp_v' \rightarrow_e v}
	{env_V, sto \vdash tupple\ @\ a \rightarrow_{tupple} v}
	\end{math}
	
	\texttt{ where } $tp_v'\ is\ the\ v'th\ element\ of\ tupple$
\end{center}

\textbf{[$ListLit_{BSS}$]}\\
\begin{center}
	\begin{math}
	env_V,\ sto \vdash tpl \rightarrow_{tupple} v
	\end{math}
	\texttt{ if } $\mathbb{TPL}[tpl] = v$
\end{center}

%\textbf{\Large{Function call Expression}}\\
%Functions returns a value $v$, where $v$ is extracted from an expression literal.
%The set of function call expression are a special case of expression, since they need to know the procedure environment $env_P$.
%This is required since the call needs to know the expression after the return keyword.
%The transition-system for functions is $(Fnames, \rightarrow_{f}, Lit)$.

%\texttt{[$FncCall_{BSS}$]}\\
%\begin{center}
%	\begin{math}
%		{env_V, sto}
%		{env_V, env_P, sto \vdash eOrL\ f\ eOrL^* \rightarrow_{f} v}
%	\end{math}
%\end{center}

%\subsection{Big-Step Semantic for Statements}
%Quick introduction.
%\textbf{Assignment}\\
%\begin{math}
%	env_v,\ env_p \vdash \langle x := e, sto \rangle \rightarrow sto[l \mapsto v]\\
%	\texttt{where } env_v,\ sto \vdash e \rightarrow_e v
%	\texttt{ and } env_v\ x = l
%\end{math}

%\textbf{Sequence}\\
%\begin{math}
%	\cfrac
%		{env_v,\ env_p \vdash \langle S_1,\ sto \rangle \rightarrow sto'' \quad env_v,\ env_p \vdash \langle S_2,\ sto'' \rangle \rightarrow sto'}
%		{env_v,\ env_p \vdash \langle S_1;S_2,\ sto \rangle \rightarrow sto'}
%\end{math}

%\textbf{If-function-true}\\
%\begin{math}
%	\cfrac
%		{env_v,\ env_p \vdash \langle S,\ sto \rangle \rightarrow sto'}
%		{env_v,\ env_p \vdash \langle b \texttt{ then } \{\ S\ \},\ sto \rangle \rightarrow sto'}\\
%	\texttt{if } env_v,\ sto \vdash b \rightarrow_b true
%\end{math}
%%TODO: Explain that "{ S }" can be replaced with :f.

%\textbf{If-function-false}\\
%\begin{math}
%	env_v,\ env_p \vdash \langle b \texttt{ then } \{\ S\ \},\ sto \rangle \rightarrow sto\\
%	\texttt{if } env_v,\ sto \vdash b \rightarrow_b false
%\end{math}

%\textbf{While-function-true}\\
%\begin{math}
%	\cfrac
%		{env_v,\ env_p \vdash \langle S,\ sto \rangle \rightarrow sto'' \quad env_v,\ env_p \vdash \langle  b %\texttt{ whileTrue } \{\ S\ \} ,\ sto'' \rangle \rightarrow sto'}
%		{env_v,\ env_p \vdash \langle b \texttt{ whileTrue } \{\ S\ \} ,\ sto \rangle \rightarrow sto'}\\
%	\texttt{if } env_v,\ sto \vdash b \rightarrow_b true
%\end{math}

%\textbf{While-function-false}\\
%\begin{math}
%	env_v,\ env_p \vdash \langle b \texttt{ whileTrue } \{\ S\ \},\ sto \rangle \rightarrow sto\\
%	\texttt{if } env_v,\ sto \vdash b \rightarrow_b false
%\end{math}

%\textbf{Foreach-function}\\
%\begin{math}
%	\cfrac
%		{env_v,\ env_p \vdash \langle T\ i := 0;\ i\ <\ (sizeof_{list} - 1) \texttt{ whileTrue } \{\ S;i := i + 1\ %\},\ sto \rangle \rightarrow sto'}
%		{env_v,\ env_p \vdash \langle list \texttt{ forEach } \{\ S\ \},\ sto \rangle \rightarrow sto'}\\
%		\texttt{where } sizeof_{list} = \text{number of elements in list}
%\end{math}

\subsection{Big-Step Semantic for Variable Declarations}
Variable declarations $Dcl_V$ can change the variable environment $Env_v$ by declaring new variables in $Var$.
They can also change the store by binding variables to new addresses.

The transition-system for $Dcl_V$ is ($(Dcl_V\ X\ Env_V\ X\ Sto) \cup Env_V\ X\ Sto, \rightarrow_{D_{V}}, Env_V\ X\ Sto$).

This means that the transitions must be on the form.

\begin{center}
	$\langle D_V,env_V,sto \rangle \rightarrow_{D_V} (env_V^{'} , sto^{'})$
\end{center}

The transitions are shown below.

\textbf{[$Dcl_VAssExp_{BSS}$]}\\
\begin{center}
	\begin{math}
	\cfrac
		{\langle D_V,\ env_V[x \mapsto l][next \mapsto l'],\ sto[l \mapsto v] \rangle \rightarrow_{D_V} (env_V',\ sto')}
		{\langle T\ x = e;\ S,\ env_V,\ sto \rangle \rightarrow_{D_V} (env_V',\ sto')}
	\end{math}
	
	\texttt{ where } $env_V,\ sto \vdash e \rightarrow_e v$
	\texttt{ and } $l = env_V\ next$
	\texttt{ and } $l' = new\ l$
\end{center}

\texttt{[$Dcl_VAssFnc_{BSS}$]}\\
\begin{center}
	\begin{math}
		\cfrac
			{\langle D_V,\ env_V[x \mapsto l][next \mapsto l'],\ sto[l \mapsto v] \rangle \rightarrow_{D_V} (env_V',\ sto')}
			{\langle T\ x = f;\ S,\ env_V,\ sto \rangle \rightarrow_{D_V} (env_V',\ sto')}		
	\end{math}
	
	\texttt{ where } $env_V,\ sto \vdash f \rightarrow_{call_{exp}} v$
	\texttt{ and } $l = env_V\ next$
	\texttt{ and } $l' = new\ l$
\end{center}

\textbf{[$Dcl_VNoAss_{BSS}$]}\\
\begin{center}
	\begin{math}
	\cfrac
		{\langle D_v,\ env_v[x \mapsto l][next \mapsto l'],\ sto \rangle \rightarrow_{D_V} (env_v',\ sto)}
		{\langle T\ x;\ S,\ env_v,\ sto \rangle \rightarrow_{D_V} (env_v',\ sto)}
	\end{math}
	
	\texttt{ where } $l = env_v\ next$
	\texttt{ and } $l' = new\ l$
\end{center}

\textbf{[$Dcl_VEmpty_{BSS}$]}\\
\begin{center}
	\begin{math}
	\langle \epsilon,\ env_v,\ sto \rangle \rightarrow (env_v,\ sto)
	\end{math}
\end{center}

\subsection{Procedure and Function Declarations}
Function declarations $Dcl_P$ can change the procedure environment $Env_P$ by declaring new functions in $Fnames$.

The transition-system for $Dcl_P$ is ($Fnames \rightharpoonup Stm\ X\ Var\ X\ Exp\ X\ Env_V\ X\ Env_P$).
This means that the transitions must be on the form.

\begin{center}
	$\langle D_P, env_V, env_P \rangle \rightarrow_{D_P} (env_P)$
\end{center}

Procedures are functions with no return value and therefore are statements.
Any function returning a value is an expression.
For simplicity, all functions will be denoted f in the function declaration transitions.

Declarations of functions must remember the expression directly following the return keyword, this is accomplished by binding the function in the procedure environment with this expression.
This is not the case for procedures, since they do not return a value.
The rules for procedures and functions are the same, except for the value $e$ being an expression in functions, it is $none$ in procedure rules.

The transitions are shown below.

\texttt{[$Dcl_PAss_{BSS}$]}\\
\begin{center}
	\begin{math}
		\cfrac
			{env_V \vdash \langle S, env_P[f \vdash (L, x\sim, e, env_V, env_P)] \rangle \rightarrow_{D_P} env_P'}
			{env_v \vdash \langle T\ f\ =\ ([T\ x]\sim):\ T\ L;\ S,env_P \rangle \rightarrow_{D_P} env_P'}
	\end{math}
\end{center}

\texttt{[$Dcl_PNoAss_{BSS}$]}\\
\begin{center}
	\begin{math}
	\cfrac
	{env_V \vdash \langle S, env_P[f \vdash (L, x\sim, e, env_V, env_P)] \rangle \rightarrow_{D_P} env_P'}
	{env_v \vdash \langle T\ f;\ S,env_P \rangle \rightarrow_{D_P} env_P'}
	\end{math}
\end{center}

\texttt{[$Dcl_Pempty_{BSS}$]}\\
\begin{center}
	\begin{math}
		{env_V \vdash \langle \epsilon, env_P \rangle \rightarrow_{D_P}\ env_P'}
	\end{math}
\end{center}



%Conclusion.